---
layout: post
date: 2019-06-20
title: Malware analysis on macOS
---

*This is part two of a multi-part series where I reverse engineer some shitty macOS malware. All the code is available [here](https://gist.github.com/xfbs/42df932fadaeb0f3888230e6ec1b0a99).*

In the last part I deobfuscated the first three stages, which were all in bash, to get to this one. 

I zipped the `Installer.app` up, copied it out of the docker container and onto my Mac Mini, where I extracted it again and checked what the signature would be.

    Brutus:malware pelsen$ codesign -dvv Installer.app/
    Executable=/private/tmp/malware/Installer.app/Contents/MacOS/Installer
    Identifier=com.inst
    Format=app bundle with Mach-O thin (x86_64)
    CodeDirectory v=20200 size=1256 flags=0x0(none) hashes=32+5 location=embedded
    Signature size=4705
    Authority=Developer ID Application: Edward Furlhoper (XL8ZVTY2W2)
    Authority=Developer ID Certification Authority
    Authority=Apple Root CA
    Info.plist entries=24
    TeamIdentifier=XL8ZVTY2W2
    Sealed Resources version=2 rules=13 files=12
    Internal requirements count=1 size=200

Not overly surprising here, it's signed by the same Edward Furlhoper as the previous App. I wonder if Apple has or will blacklist this certificate, but I don't want to test it by launching this App. 

Next, let's go back to the container and inspect the code. It is interesting that the code seems to contain some GUI, because you can see some `.nib` files in the App. The executable isn't very big, it's merely 150 kB of code.

    $ ls -lh Installer.app/Contents/MacOS/
    total 304
    -rwxrwxr-x  1 pelsen  staff   148K Jun 10 12:04 Installer

At this point, there are multiple methods to reverse engineer this thing. The simple method would be to launch a macOS VM, and execute the malware in there. There are some facilities for tracing executables with `dtrace`, such as `dtruss` that let one capture all system calls an executable performs. 

The other possibility is to disassemble the executable. This is a bit more involved, might be more complicated but might also give us more information. First we can do a bit of static analysis on the code.

    $ strings Installer.app/Contents/MacOS/Installer
    class
    alloc
    init
    setRunningInstallCount:
    defaultCenter
    mainQueue
    ...

Strings shows us any ASCII-character strings embedded in the binary file. There are some interesting ones that refer to, perhaps unsurprisingly, an installer. 

    INSTALLER_authorize
    INSTALLER_installOffer:
    performSelectorOnMainThread:withObject:waitUntilDone:
    INSTALLER_downloadOffer:path:
    INSTALLER_runExternalApplication:args:
    INSTALLER_postInstall:
    INSTALLER_runScript:

This app looks like it might be an actual installer to install something. The question is, what might it install, and where would it get that from? Seeing that the binary is quite small, it seems plausible that it could download things from the internet to install. These are some symbols (functions) defined in the binary that would point in that direction:

    sendSynchronousRequest:returningResponse:error:
	INSTALLER_getDownURLParams
	openURL:
	INSTALLER_getPostURL
	INSTALLER_getDownloadHashId
	INSTALLER_downloadFileToPath:path:

Additionally, looking through the strings we can find something that appears to be Base85 encoded data, which might be something interesting. There is quite a lot in there, might be worth decoding all of them.

	TRYEGVo6BAQMG1AZBkwaAQ==
	TRYEGVoYAQ0HD1sGCg==
	TRYEGVoZAQ0HD1sGCg==
	ChYdGU9aTQsCAx0BEEwQBgcBC0wZHlocEU0eDBcDXQYADUg=
	ChYdGU9aTQsCAx0BEEwQBgcBC0wZHlocEU0eDBcDCwceVhEcBl8=
	ChYdGU9aTQsCAx0BEEwQBgcBC0wZHlocEU0ODR0cBl0NABFI

It also contains some interesting strings that sound like they might belong to some control server, and `/bin/sh` which is indicative of opening a shell or launching some script.

	/bin/sh
	http://ddse3e.space/kl/njdhu?dd=[DHIS]
	/Volumes/Installer/
	control
	goodbye
	/etc/hosts

With all of these clues, we have enough evidence that it might be useful to actually load up a disassembler and play Sherlock Holmes. But first, I wanted to check out what those base64-encoded strings are, so I extracted all of them from the `strings` output into a file, and used a little bash one-liner to decode all of them.

    $ for line in $(< strings.txt); do echo $line; echo $line | base64 -D | xxd; done
    TRIFCBYQEUwaGBkcFgc=
    00000000: 4d12 0508 1610 114c 1a18 191c 1607       M......L......
    NgcbBBwbAw4=
    00000000: 3607 1b04 1c1b 030e                      6.......
    NQsbDAYdAxACRxQFEg==
    00000000: 350b 1b0c 061d 0310 0247 1405 12         5........G...
    ...

However, most of them didn't look like anything useful. Could be some x86 bytecode, but judging by the rest of this malware, I somehow don't think they would do that. However, there is one part that looks like it could be interesting. Just to be sure, I extracted all of them so I could use `binwalk` to check if they are anything interesting.

    $ mkdir unpacked
    $ for line in $(< strings.txt); do echo $line; echo $line | base64 -D > unpacked/$line; done
    $ binwalk unpacked/*
    Scan Time:     2019-06-18 01:48:27
    Target File:   /Users/pelsen/Projects/Playground/malware/installer/unpacked/AQ0ERxQFEg4MRxgQFgMNCAEUW
    AkkLTwBBw8+ARAHByQbBhgG
    MD5 Checksum:  06a9e3f32332ad79e338c581822a6df5
    Signatures:    344

    DECIMAL       HEXADECIMAL     DESCRIPTION
    --------------------------------------------------------------------------------
    
    ...

However, none of these had any interesting header or anything. The only two interesting ones are also the longest strings, and they decode to some long characters:

    TT^[0F'UD/CM&O\XA0O ]QBXRTPPL3P#^-BB='^P46VZZDB6$TD\AEWOP,00O#Z+63$UY\C7R=[QBL'V^*XEZ![D@CTZDQD1RO,^GEU!Y[1BZ[6\D0'S**0XT!ZYX@ST[DMAU[D]D3 !(,@7#RY67DSW(XG3OT-ZMXWU,[XLV!*D30W#-_B6QUQ[*7# X,1F#OQ[33OW_YMX#W-,X1SVQP06QS([F*VR\YM7PUD\FD O\(6DO \-4X& **L4&UY[ML=W_]1DU _D@0T[DPL1RO[_BFOVZZDCV&(]@AQ=_Y31#SP-X0UVQD@B!SDQCD'O_]LFSR-ZA7'$6]E6QW[[0X$ Q,X@U[(D4DRRD,EM!$QYDBZ [6BATQQ[B0OR((CXWP,YX7'#_DFGV[,+6C#Z[]*FTZ(\16[O-(3LOWX^6X  (*XF!QY,6GTR(QF*SR]_07'QD(C4 O\/MMO[Z\7XV#-*4LSPY_0F=[++0@ U]DA7!ZD\B0TOPZC3OU^/@0 WQY6C'=\_A1 Z]\XDRRYDF4T&D_0F OQ]AL!T--1EQ!6[FMU$-[3X!VZ-X@S!YDL3Z!DPEGVUQ(03!ZY

    TZYYEA[!D]4@VO]]DBO Q]AXV!P(7ES!+[DA=W_]10!Z/D1DT$DZC0TOP]@3OP*_A0'Z[,0L#=QYGMQ$+QX4QPZD@MQ'D(DG$O[]3C#T_\BBT[6\@4&'PZEXW$-/X@'!]DMAP[DX@CVR_QA6VZP6FB'Z\QDDO ,^GXW$-YXL&Z/D0A[#,ZAETS^,*6&UZXEM#OQ]DEOW*(LX[W--X1PR_+GB'R_YF*[W^\40&!DZ37QO\(MBO[\,1XR$([GFPZZQ63

I would have guessed that these could be base85 encoded, however there don't seem to any lowercase characters. As we remember from how this code is launched, it gets some parameters, including a password, as parameter. It is possible that some of these things are decrypted with the amateurish "encryption", if you can even call it that, as they used in the bash scripts. 

At this point I should probably mention that this is the first time I'm doing anything like this, reverse engineering something. I am vaguely familiar with x86 assembly and Objective-C. I might fall into some beginner's traps or do something stupid. But we're on this journey here to learn, and that sometimes includes making dumb mistakes.

So I went ahead and fired up Hopper, a nice disassembler for macOS and Linux. This helps a lot, Hopper gives me a lot more information, but it takes some time to get familiar with it. 

![Hopper disassembler with malware loaded](/assets/images/malware-disassembler.png)

First I just jumped through the whole binary, trying to get an overview of what things I might find in it. There were some interesting things, all of the strings we found are embedded, and there are also some strange method names that look like obfuscation attempts:

    [ltst shLt]
    [ltst ghfyrtbv]
    [ltst trToEn:]
    [ltst trMeNw:]
    [apes KKerwerwWQ]
    [apes reuwqwer3]

We'll get to these later, and we'll find out what they do. Since I don't really know how this binary works, I started by following the code from the top, that is, from something that looks like a main function, which was actually the first function in the binary, `[InstallerOffers INSTALLER_startSetup:]`. Now, because I'm not that great at reading assembly, I just asked Hopper to give me some pseudocode. The code that it generates is actually surprisingly readable for this.

![Malware startSetup function pseudo code](/assets/images/malware-startsetup-disassembled.png){:width="50%"}

You can see how at the end it just calls the `INSTALLER_getOffers` method. By doing this repeatedly, looking at the pseudocode and figuring out what is called, I managed to slowly make my way through the whole binary, following functions around. Not particularily hard, since the binary is tiny and only has a handful of functions. 

But we'll get back to these laters.




The whole code of this, including the deobfuscated version, is available [here](https://gist.github.com/xfbs/42df932fadaeb0f3888230e6ec1b0a99), if you want to inspect it.





Downloads usually come as .dmg files on macOS, these are disk images, a remnant from the time where software was distributed in the form of physical disks. These are compressed and contain a small file system, that you can mount. So I did.

Unsurprisingly, I found a small installer inside. I do think that some people would be dumb enough to just launch it, withouth checking what it does, but that's not what I was planning to do. This being macOS malware, which is basically fruitless, I was quite sure that this was written by some kid. It might actually do something, but it's probably nothing advanced. So I went ahead, opened Terminal.app, and checked what's in there.

A bash script. How interesting. I mean, it's quite obvious, if you're writing malware for a platform, you'd probably want to do it as simple as possible, and use the things that are preinstalled. And macOS happens to come with `bash` and `openssl`, so they used that.
