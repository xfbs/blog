---
layout: post
date: 2019-06-20
title: "Malware analysis on macOS, Part 2: Disassembly"
summary: "This is part two of a multi-part series where I reverse-engineer some shitty macOS malware. In this post, I reverse-engineer a binary using a disassembler to find out what it does."
---

*This is part two of a multi-part series where I reverse engineer some shitty macOS malware. All the code is available [here](https://gist.github.com/xfbs/42df932fadaeb0f3888230e6ec1b0a99).*

In the last part I deobfuscated the first three stages, which were all in bash, to get to this one. The last bash staged downloaded a ZIP file and extracted it, producing an `Installer.app`.

I zipped the `Installer.app` up, copied it out of the docker container and onto my Mac, where I extracted it again and used that trusty `codesign` utility to check what the signature here might be.

    Brutus:malware pelsen$ codesign -dvv Installer.app/
    Executable=/private/tmp/malware/Installer.app/Contents/MacOS/Installer
    Identifier=com.inst
    Format=app bundle with Mach-O thin (x86_64)
    CodeDirectory v=20200 size=1256 flags=0x0(none) hashes=32+5 location=embedded
    Signature size=4705
    Authority=Developer ID Application: Edward Furlhoper (XL8ZVTY2W2)
    Authority=Developer ID Certification Authority
    Authority=Apple Root CA
    Info.plist entries=24
    TeamIdentifier=XL8ZVTY2W2
    Sealed Resources version=2 rules=13 files=12
    Internal requirements count=1 size=200

Unsurprisingly, it's signed by the same *Edward Furlhoper* as the previous App. I would presume that it should be quite easy for Apple to simply blacklist this particular certificate, and it is possible that Apple has already done so, but the only way I know to test that would be to execute this, which is not something I'd like to do.

Next, let's go back to the container and inspect the code. There's a single executable, `Installer`, inside the app. Using the handy `file` utility, we see that this is a Mach-O executable, and that at 150 kB it's rather small.

    $ ls -lh Installer.app/Contents/MacOS/
    total 304
    -rwxrwxr-x  1 pelsen  staff   148K Jun 10 12:04 Installer
    $ file Installer.app/Contents/MacOS/Installer 
    Installer.app/Contents/MacOS/Installer: Mach-O 64-bit x86_64 executable, flags:<NOUNDEFS|DYLDLINK|TWOLEVEL|PIE>

The `Installer.app` also contains some `.nib` files, which suggest that it has a GUI. They are from Apple's Interface Builder.

Before we do anything fancy with the executable, it makes sense to gather some information about it with some handy utilities. The `strings` utility just prints out anything that looks like printable character sequences. That's a pretty long list, but some of those might be interesting to us.

    $ strings Installer.app/Contents/MacOS/Installer
    class
    alloc
    init
    setRunningInstallCount:
    defaultCenter
    mainQueue
    ...

There are some interesting ones that tell me what this binary might do. First are a lot of what look like symbols (function names) referring to an Installer. That suggests that this thing is actually an installer (or masquerades as one). Since this binary is rather small, I think that this is really just another stage that downloads something and runs or installs it.

    INSTALLER_authorize
    INSTALLER_installOffer:
    performSelectorOnMainThread:withObject:waitUntilDone:
    INSTALLER_downloadOffer:path:
    INSTALLER_runExternalApplication:args:
    INSTALLER_postInstall:
    INSTALLER_runScript:

There are some strings that suggest it performs some network requests and possibly downloads something.

	INSTALLER_getDownURLParams
	openURL:
	INSTALLER_getPostURL
	INSTALLER_getDownloadHashId
	INSTALLER_downloadFileToPath:path:

And last, there are a lot (~50) strings that look to be base64-encoded data.

	TRYEGVo6BAQMG1AZBkwaAQ==
	TRYEGVoYAQ0HD1sGCg==
	TRYEGVoZAQ0HD1sGCg==
	ChYdGU9aTQsCAx0BEEwQBgcBC0wZHlocEU0eDBcDXQYADUg=
	ChYdGU9aTQsCAx0BEEwQBgcBC0wZHlocEU0eDBcDCwceVhEcBl8=
	ChYdGU9aTQsCAx0BEEwQBgcBC0wZHlocEU0ODR0cBl0NABFI

Last, it also contains some interesting strings that sound interesting.

	/bin/sh
	http://ddse3e.space/kl/njdhu?dd=[DHIS]
	/Volumes/Installer/
	control
	goodbye
	/etc/hosts

With all of these clues, we have enough evidence to tell that this is doing something shady. At this point, I'm mostly interested in the base64-encoded data. What is it for, and what are they trying to obfuscate with that? 

I did the obvious thing and extracted all of strings that look like they are base64-encoded into a file, and wrote a little bash one-liner to decode them all and show me what they encode.

    $ for line in $(< strings.txt); do echo $line; echo $line | base64 -D | xxd; done
    TRIFCBYQEUwaGBkcFgc=
    00000000: 4d12 0508 1610 114c 1a18 191c 1607       M......L......
    NgcbBBwbAw4=
    00000000: 3607 1b04 1c1b 030e                      6.......
    NQsbDAYdAxACRxQFEg==
    00000000: 350b 1b0c 061d 0310 0247 1405 12         5........G...
    ...

This wasn't particularily helpful as they all decoded just fine, but gave back something that looked like binary data. I was expecting printable characters and things like paths, urls, but it seems like they are doing a bit more with these than just base64-encoding them.

Just to be sure, I used `binwalk`, another useful utility, to see if there is any interesting binary data in these files. 

    $ mkdir unpacked
    $ for line in $(< strings.txt); do echo $line; echo $line | base64 -D > unpacked/$line; done
    $ binwalk unpacked/*
    Scan Time:     2019-06-18 01:48:27
    Target File:   /Users/pelsen/Projects/Playground/malware/installer/unpacked/AQ0ERxQFEg4MRxgQFgMNCAEUW
    AkkLTwBBw8+ARAHByQbBhgG
    MD5 Checksum:  06a9e3f32332ad79e338c581822a6df5
    Signatures:    344

    DECIMAL       HEXADECIMAL     DESCRIPTION
    --------------------------------------------------------------------------------
    
    ...

But again, no luck. I guess it's time to get out the big guns, after all.

There are multiple options for analysing binaries. IDA Pro come to mind, also the Ghidra software recently released by the NSA. I went with [Hopper Disassembler](https://www.hopperapp.com/), which has a very pleasant interface and good support for macOS things like Objective-C. At this point I should maybe mention that this was the first time I reverse-engineere anything, so this is a bit of a learning-by-doing adventure.

I went ahead and launched Hopper, and told it to load up and analyze the binary.

![Hopper disassembler with malware loaded](/assets/images/malware-disassembler.png)

It took me a bit of time to get used to Hopper's interface, but it's quite straightforward. On the left side, there is a list of labels (functions) or strings, they can be searched and by clicking on one, it can be jumped to. In the center is the disassembly, which is the complete binary, and can be scrolled from top to bottom. Most useful are also the button in the top-right corner that generates pseudocode from a disassembled function, and it handles Objective-C really well.

At first, I was a bit confused, because I didn't know what the entry point of this executable would be, because it doesn't have a `main()` function. But then I found a function helpfully labelled `EntryPoint`, located at offset `0xaf4b`. 

![Malware entrypoint assembly](/assets/images/malware-entrypoint-asm.png)

From the assembly it's already quite obvious to see what this does, there's a call to `sub_100009892` and a call to `NSApplicationMain`. 

The call to `sub_100009892` is very interesting, because that is a very important method in order to understand the binary.

<!-- todo: image -->

From the assembly of this function it's not really obvious (to me, anyways) what this does. Thankfully, Hopper can generate some really helpful pseudocode from assembly.

![Malware decrypt_strings method pseudocode](/assets/images/malware-decrypt-strings-pseudo.png){:width="80%"}

You can see that I have renamed the method to `decrypt_strings` to give it a slightly more useful name, and if you look at what it does, you will understand why. It seems to overwrite global string variables with their decrypted versions.

In order to understand this, you have to understand that Objective-C uses message-passing. So the `_objc_msgSend` function sends a message to the class `Utilities`. The message it sends, stored in `r15`, is the selector `decrypt`. We're essentially asking the `Utilities` class to call the `decrypt:` method. There is a colon after the `decrypt`, which means that this method takes an argument. Hopper doesn't recognize this and doesn't show it, but whatever is in `rdx` gets passed as the argument to the function.

Ignoring the retain and release calls, which I think have to do with reference counting that Objective-C uses for easier memory managemenet, these calls look like this:

```objective-c
@"JQ09BiU..." = [Utilities decrypt: @"JQ09BiU..."];
@"JQ09BjM..." = [Utilities decrypt: @"JQ09BjM..."];
```

Now we know that these base64-encoded strings are indeed obfuscated somehow, because this function is quite long and it seems to do this thing with all the base64-encoded strings in the binary. It would probably be a good idea to check out `[Utilities decrypt:]` next to see what it does and maybe reverse it. Judging by the quality of the code so far, it should be really easy.

Simply searching for this method in the labels list of Hopper made it trivial to locate, and this is what the pseudocode for it looks like.

![Malware decrypt pseudocode](/assets/images/malware-decrypt-pseudo.png)

It's a bit messy and I had to deactivate the *Remove potentially dead code* because it was hiding some important implicit arguments to some of the function calls. But this is enough for us to see the general structure of the code.

I was able to rewrite most of this function in Objective-C, by simply following the pseudocode and occasionally looking into the macOS Foundation framework headers (located at `/System/Library/Frameworks/Foundation.framework/Headers`) to find the name of constants. If you know how Objective-C method calls look like, it's actually very easy.

The function looks something like this:

```objective-c
NSString *arg2 = @"JQ09BjU...";
NSData *data = [[NSData alloc] initWithBase64EncodedString: arg2 options: NSDataBase64DecodingIgnoreUnknownCharacters];
NSString *decoded = [[NSString alloc] initWithData: data encoding: NSASCIIStringEncoding];
NSMutableString *out = [[NSMutableString alloc] init];
unichar key[] = {'b', 'i', 'u'};

for(uint32_t i = 0; i < [decoded length]; i++) {
  unichar c = [decoded characterAtIndex: i];
  unichar processed = ???;
  [out appendString: [NSString stringWithFormat: @"%C", processed]];
}

return out;
```

I ran into and issue that I couldn't quite decode the inside of the loop. Something wasn't adding up, I either didn't understand the pseudocode quite right or Hopper was not recognising the right arguments.

You can see that it's doing something with the XOR there. It's probably just rotating the `key` (which is hardcoded into the function and only three characters, so quite pathetic) and XORing that with the decoded string data. But I didn't really know for sure.

After much struggling, I ended up chaging my approach. Instead of trying to reverse this loop, I would just run it and see what it does. This is the assembly in question

![Malware loop assembly](/assets/images/malware-decrypt-loop-asm.png)

The issue is that at `0x00000001000050ba` the instruction performs an XOR with the current byte of the string `ax` and they byte of the key with offset `rcx`. What I need to know to reimplement this is which offsets it's using.

```asm
xor     ax, word [ss:rbp+rcx+var_2E]
```

I was able to isolate the relevant parts into another file, and modify it a bit to remove external calls and make it output the contents of the `rcx` register. This code is available [here](https://gist.github.com/xfbs/42df932fadaeb0f3888230e6ec1b0a99#file-decrypt_loop-asm).

![Malware loop assembly reversed](/assets/images/malware-decrypt-loop-reversed.png){:width="80%"}

This can be compiled with `nasm` and run to inspect the contents of the `rcx` register, which is written on standard output as a byte, during every invocation of the loop. Because this relies on the way macOS does syscalls, it can only be run on a macOS host, but the syscall can trivially be rewritten.

```
$ nasm -f macho64 decrypt_loop.asm
$ ld -macosx_version_min 10.7.0 -lSystem -o decrypt_loop decrypt_loop.o
$ ./decrypt_loop | xxd | head
00000000: 0000 0202 0404 0000 0202 0404 0000 0202  ................
00000010: 0404 0000 0202 0404 0000 0202 0404 0000  ................
00000020: 0202 0404 0000 0202 0404 0000 0202 0404  ................
00000030: 0000 0202 0404 0000 0202 0404 0000 0202  ................
00000040: 0404 0000 0202 0404 0000 0202 0404 0000  ................
00000050: 0202 0404 0000 0202 0404 0000 0202 0404  ................
00000060: 0000 0202 0404 0000 0202 0404 0000 0202  ................
00000070: 0404 0000 0202 0404 0000 0202 0404 0000  ................
00000080: 0202 0404 0000 0202 0404 0000 0202 0404  ................
00000090: 0000 0202 0404 0000 0202 0404 0000 0202  ................
```

As can be seen from the output, the contents of the register `rcx` follow the repeating pattern 0, 0, 2, 2, 4, 4 and wrap around, so I was right. The reason why it always increases by two instead of by one is that on macOS, a `unichar` has a width of 2 bytes. This is for legacy reasons, probably because two bytes was enough to hold all unicode characters back when this was designed, but means that in an array of `unichar`s, to get the next item the pointer difference is two. 

With this information, I was able to complete the reversed `decode` method.

```objective-c
unichar processed = c ^ key[(i / 2) % 3];
```

The whole code for this is available [here](https://gist.github.com/xfbs/42df932fadaeb0f3888230e6ec1b0a99#file-decrypt-m). This code deobfuscates the string that it is passed as argument, like so.

```bash
$ clang -o decrypt -framework Foundation decrypt.m
$ ./decrypt BAMKDBcaDQlHChoY
facebook.com
```

That was surprisingly easy. Next, I used a little bash one-liner to decode all of the base64-encoded strings of the binary that I have in a `strings.txt`.

```bash
$ for line in $(< strings.txt); do echo $line; ./decrypt $line; done
```

Most of these strings only make sense in context. My next task is to actually walk through the code and reverse it to find out what it's actually doing. I'm looking especially for anything related to network, like accessing URLs and downloading things, because I'm sure that this will grab the next stage.


<!--

First I just jumped through the whole binary, trying to get an overview of what things I might find in it. There were some interesting things, all of the strings we found are embedded, and there are also some strange method names that look like obfuscation attempts:

    [ltst shLt]
    [ltst ghfyrtbv]
    [ltst trToEn:]
    [ltst trMeNw:]
    [apes KKerwerwWQ]
    [apes reuwqwer3]

We'll get to these later, and we'll find out what they do. Since I don't really know how this binary works, I started by following the code from the top, that is, from something that looks like a main function, which was actually the first function in the binary, `[InstallerOffers INSTALLER_startSetup:]`. Now, because I'm not that great at reading assembly, I just asked Hopper to give me some pseudocode. The code that it generates is actually surprisingly readable for this.

![Malware startSetup function pseudo code](/assets/images/malware-startsetup-disassembled.png){:width="50%"}

You can see how at the end it just calls the `INSTALLER_getOffers` method. By doing this repeatedly, looking at the pseudocode and figuring out what is called, I managed to slowly make my way through the whole binary, following functions around. Not particularily hard, since the binary is tiny and only has a handful of functions. 

But we'll get back to these laters.




The whole code of this, including the deobfuscated version, is available [here](https://gist.github.com/xfbs/42df932fadaeb0f3888230e6ec1b0a99), if you want to inspect it.





Downloads usually come as .dmg files on macOS, these are disk images, a remnant from the time where software was distributed in the form of physical disks. These are compressed and contain a small file system, that you can mount. So I did.

Unsurprisingly, I found a small installer inside. I do think that some people would be dumb enough to just launch it, withouth checking what it does, but that's not what I was planning to do. This being macOS malware, which is basically fruitless, I was quite sure that this was written by some kid. It might actually do something, but it's probably nothing advanced. So I went ahead, opened Terminal.app, and checked what's in there.

A bash script. How interesting. I mean, it's quite obvious, if you're writing malware for a platform, you'd probably want to do it as simple as possible, and use the things that are preinstalled. And macOS happens to come with `bash` and `openssl`, so they used that.


-->
